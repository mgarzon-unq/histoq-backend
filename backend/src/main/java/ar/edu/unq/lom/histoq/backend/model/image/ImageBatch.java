package ar.edu.unq.lom.histoq.backend.model.image;

import ar.edu.unq.lom.histoq.backend.model.protocol.Individual;
import ar.edu.unq.lom.histoq.backend.model.user.User;
import lombok.Data;
import javax.persistence.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.util.stream.Collectors.groupingBy;

@Data
@Entity (name = "image_batch")
public class ImageBatch {
    private @Id
    @GeneratedValue
    Long id;
    private Date date = new Date();
    private boolean applyStitching = false;
    @ManyToOne
    private Individual individual;
    @ManyToOne
    private User user;

    @OneToMany(cascade=CascadeType.ALL, mappedBy="batch", orphanRemoval=true)
    private List<ImageFile> imageFiles = new ArrayList<ImageFile>();

    public ImageBatch(){}

    public void addImageFile(ImageFile imageFile) {
        getImageFiles().add(imageFile);
        imageFile.setBatch(this);
    }

    public void removeImageFile(ImageFile imageFile) {
        getImageFiles().remove(imageFile);
        imageFile.setBatch(null);
    }

    public void removeImageFiles(Predicate<ImageFile> predicate) {
        List<ImageFile> imageFiles = getImageFiles().stream().filter(predicate).collect(Collectors.toList());
        imageFiles.forEach(file -> {
            file.getImage().removeImageFile(file);
            removeImageFile(file);
        });
    }

    public List<ImageFile> getUploadedImageFiles() {
        Predicate<ImageFile> notAutoGenerated = (ImageFile file) -> !file.isGenerated() || file.isStitched();
        return getImageFiles()
                .stream()
                .filter(notAutoGenerated)
                .collect(Collectors.toList());
    }

    public List<Image> process(ImageScanner scanner) {
        // remove files generated by previous processing...
        removeImageFiles(ImageFile::isGenerated);

        List<ImageFile> imageFiles = new ArrayList<>(( isApplyStitching() ? stitchImageFiles(scanner): getImageFiles() ));

        return imageFiles  // select the files to process, depending on the stitching mode...
                .stream()
                .map( imageFile -> processImageFile(imageFile,scanner))
                .collect(Collectors.toList());
    }

    private Image processImageFile(ImageFile imageFile, ImageScanner scanner) {

        Image image = scanner.processImageFile(imageFile);

        image.addImageFile(imageFile);  // reference the results so then
        imageFile.setImage(image);      // persistence save the changes..

        return image;
    }

    private List<ImageFile> stitchImageFiles(ImageScanner scanner) {

        // group regular files by their stitching group...
        Map<String, List<ImageFile>> groupedImageFiles = getImageFiles()
                .stream()
                .collect(groupingBy(ImageFile::getStitchingGroup));

        // send each group to the stitching process...
        return groupedImageFiles.entrySet().stream().map( group -> {
                    ImageFile imageFile = scanner.stitchImageFiles(group.getValue(),group.getKey());
                    imageFile.setGenerated(true);   // tag the new file as generated by processing...
                    imageFile.setStitched(true);    // tag the new file as created by stitching...
                    addImageFile(imageFile);        // add file to the batch...
                    return imageFile;
                })
                .collect(Collectors.toList());
    }


}
